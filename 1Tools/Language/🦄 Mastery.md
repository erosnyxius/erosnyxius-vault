## **Step 1 — Core Fundamentals**

* [ ] **Variables** – naming rules, assignment, reassignment, mutable vs immutable.
* [ ] **Data Types** – integers, floats/doubles, strings, booleans, null/undefined.
* [ ] **Operators**

  * [ ] Arithmetic: `+ - * / %`
  * [ ] Comparison: `== != < > <= >=`
  * [ ] Logical: `AND / OR / NOT`
  * [ ] Assignment: `= += -= *= /=`
* [ ] **Expressions** – combining variables and operators.
* [ ] **Control Flow**

  * [ ] If / Else
  * [ ] Switch / Match (if supported)
* [ ] **Loops**

  * [ ] For
  * [ ] While
  * [ ] Break / Continue
* [ ] **Functions**

  * [ ] Defining functions / methods
  * [ ] Parameters and arguments
  * [ ] Return values
  * [ ] Recursion
* [ ] **Scope & Lifetime**

  * [ ] Local vs global
  * [ ] Block / function / lexical scope
  * [ ] Variable lifetime
* [ ] **Input / Output**

  * [ ] Console I/O
  * [ ] File I/O



---
## **Step 2 — Data Structures & Algorithms**

* [ ] **Arrays / Lists** – ordered sequences
* [ ] **Tuples / Records** (if supported)
* [ ] **Sets** (if supported)
* [ ] **Maps / Dictionaries / Key→Value** – fast lookup
* [ ] **Stacks & Queues** – LIFO/FIFO concepts
* [ ] **Trees** – hierarchical structures
* [ ] **Graphs** – nodes and edges
* [ ] **Algorithms**

  * [ ] Sorting: bubble, selection, merge, quick
  * [ ] Searching: linear, binary
  * [ ] Traversal: tree/graph
* [ ] **Time & Space Complexity** – Big-O notation

## **Step 3 — Procedural Programming**

* [ ] Top-down structured programming
* [ ] Functions & modular programming
* [ ] Code organization & reusability

---

## **Step 4 — Object-Oriented Programming (if supported)**

* [ ] **Classes & Objects**

  * [ ] Class = blueprint
  * [ ] Object = instance
* [ ] **Properties / Fields**
* [ ] **Methods / Functions inside objects**
* [ ] **Encapsulation** – hide internal data, expose public interface
* [ ] **Inheritance & Hierarchies** – derive one class from another
* [ ] **Polymorphism (overloading/overriding)** – same method name, different behavior per class
* [ ] **Abstraction** – exposing only necessary details, hiding implementation
* [ ] **Interfaces / Abstract Classes** (if supported) – enforce structure without implementation
* [ ] **Design principles (SOLID, DRY)**

---
## **Step 5 — Functional Programming (if supported)**

* [ ] Pure functions – same input → same output, no side effects
* [ ] Immutability – never modify existing data
* [ ] Higher-order functions – accept or return functions
* [ ] Map / Filter / Reduce – functional operations
* [ ] Function composition – combining small functions

---
## **Step 6 — Memory, Type System & Error Handling**

* [ ] **Memory model**

  * [ ] Stack vs Heap
  * [ ] Variable lifetime and scope
* [ ] **Garbage Collection** (if supported)
* [ ] **Manual Memory Management** (if supported)
* [ ] **Type System**

  * [ ] Static typing
  * [ ] Dynamic typing
  * [ ] Type inference (if supported)
  * [ ] Casting / type conversion
* [ ] **Errors & Exceptions**

  * [ ] Try / Catch / Throw / Raise
  * [ ] Error propagation
  * [ ] Graceful handling

---
## **Step 7 — Runtime Execution Model**

* [ ] Call Stack & stack frames
* [ ] Parameter passing: by value, by reference, copy-on-write
* [ ] Evaluation order: left-to-right, short-circuit boolean
* [ ] Tail Call Optimization (if supported)
* [ ] Concurrency (if supported)
* [ ] Parallelism (if supported)
* [ ] Async / Await / Event Loop (if supported)

---
## **Step 8 — Compilation / Interpretation Mechanics**

* [ ] Lexer / Tokenization
* [ ] Parser & AST (Abstract Syntax Tree)
* [ ] Interpreter (if supported)
* [ ] Compiler (if supported)
* [ ] JIT Compilation (if supported)
* [ ] Bytecode (if supported)
* [ ] Machine code
* [ ] Modules / Namespaces
* [ ] Import / Export rules / Visibility

---
## **Step 9 — Advanced Language Power Features**

* [ ] Generics / Templates (if supported)
* [ ] Pattern Matching (if supported)
* [ ] Operator Overloading (if supported)
* [ ] Metaprogramming

  * [ ] Macros (if supported)
  * [ ] Annotations / Attributes / Decorators (if supported)
  * [ ] Reflection / Introspection (if supported)
* [ ] Custom Iterators / Iterable Protocol (if supported)

---
## **Step 10 — Development Workflow & Professional Skills**

* [ ] Debugging – breakpoints, stepping, inspecting variables
* [ ] Logging & Tracing – monitoring program execution
* [ ] Testing – unit tests, integration tests
* [ ] Build system – compiling, bundling, running code
* [ ] Package Manager (if supported)
* [ ] Documentation & Code Commenting